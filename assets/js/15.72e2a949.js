(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{470:function(e,n,t){"use strict";t.r(n);var r=t(60),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"software-flashen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#software-flashen"}},[e._v("#")]),e._v(" Software / Flashen")]),e._v(" "),r("p",[e._v("Die Software für den Microcontroller wird bei Arduino als "),r("em",[e._v("Sketch")]),e._v(" bezeichnet.")]),e._v(" "),r("p",[e._v("Da der Arduino-Pro-Mini mit einem entsprechendem Bootloader ausgeliefert wird, kann ein Sketch direkt über USB-UART Adapter\ngeflasht werden wie zum Beispiel dem FTDI, der den Arduino mit dem PC verbindet.")]),e._v(" "),r("h2",{attrs:{id:"sketch-download-und-anpassen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sketch-download-und-anpassen"}},[e._v("#")]),e._v(" Sketch download und anpassen")]),e._v(" "),r("p",[e._v("Es gibt mittlerweile viele fertige "),r("RouterLink",{attrs:{to:"/Sketche/"}},[e._v("Sketche")]),e._v(" die je nach Aktor oder Sensor verwendet werden können."),r("br"),e._v("\nAls Beispiel wird hier der "),r("code",[e._v("HM-RC-P1")]),e._v(" Paniktaster genommen.")],1),e._v(" "),r("p",[e._v("Der komplette Sketch ist "),r("a",{attrs:{href:"https://github.com/pa-pa/AskSinPP/blob/master/examples/HM-RC-P1/HM-RC-P1.ino",target:"_blank",rel:"noopener noreferrer"}},[e._v("HM-RC-P1.ino"),r("OutboundLink")],1),e._v(".")]),e._v(" "),r("p",[r("strong",[e._v("Achtung")]),e._v(": Ein "),r("em",[e._v('"Seite speichern unter"')]),e._v(" der Github-URL lädt die HTML-Version herunter und nicht direkt den Source-Code.\nDieser kann über den Button "),r("code",[e._v("Raw")]),e._v(" aufgerufen werden: "),r("a",{attrs:{href:"https://raw.githubusercontent.com/pa-pa/AskSinPP/master/examples/HM-LC-Bl1-FM/HM-LC-Bl1-FM.ino",target:"_blank",rel:"noopener noreferrer"}},[e._v("HM-RC-P1.ino im Raw-Format"),r("OutboundLink")],1),e._v(" Zudem wird nicht empfohlen "),r("em",[e._v("Notepad")]),e._v(" oder gar Word zum editieren zu verwenden sondern einen "),r("em",[e._v("echten")]),e._v(" Editor wie VSCode, Sublime, Atom, Notepad++, Vim, Emacs usw.")]),e._v(" "),r("h3",{attrs:{id:"io-konfiguration"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#io-konfiguration"}},[e._v("#")]),e._v(" IO-Konfiguration")]),e._v(" "),r("div",{staticClass:"language-cpp line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-cpp"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Arduino pin for the config button")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token macro property"}},[r("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),r("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("define")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token macro-name"}},[e._v("CONFIG_BUTTON_PIN")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token expression"}},[r("span",{pre:!0,attrs:{class:"token number"}},[e._v("8")])])]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Arduino pins for the buttons")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// A0 == PIN 14")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token macro property"}},[r("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),r("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("define")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token macro-name"}},[e._v("BTN1_PIN")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token expression"}},[r("span",{pre:!0,attrs:{class:"token number"}},[e._v("14")])])]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br")])]),r("p",[e._v("Hier sieht man die Button Belegung und kann diese entsprechend anpassen."),r("br"),e._v("\nFür das Beispiel des Paniktasters schließen wir also den Config-Button an "),r("code",[e._v("GPIO-8")]),e._v(" und "),r("code",[e._v("GND")]),e._v(" sowie einen weiteren Taster an "),r("code",[e._v("GPIO-14")]),e._v(" (bzw "),r("code",[e._v("A0")]),e._v(") und "),r("code",[e._v("GND")]),e._v(" an.")]),e._v(" "),r("h3",{attrs:{id:"device-konfiguration"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#device-konfiguration"}},[e._v("#")]),e._v(" Device-Konfiguration")]),e._v(" "),r("p",[e._v("Der DeviceInfo Block identifiziert das neue Device:")]),e._v(" "),r("div",{staticClass:"language-cpp line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-cpp"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// define all device properties")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("struct")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("DeviceInfo")]),e._v(" PROGMEM devinfo "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x12")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x09")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x01")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("       "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Device ID")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token string"}},[e._v('"JPLRCP2001"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("           "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Device Serial")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x00")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x1a")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("            "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Device Model")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x11")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("                   "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Firmware Version")]),e._v("\n    as"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("DeviceType"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("Remote"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Device Type")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x00")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x00")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("             "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Info Bytes")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br")])]),r("div",{staticClass:"custom-block warning"},[r("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),r("p",[e._v("Jedes Gerät in einer HomeMatic Umgebung hat 2 eindeutige Identifikationsmerkmale:")]),e._v(" "),r("ul",[r("li",[e._v("die 10-stellige Seriennummer (wird in der WebUI in der Spalte Seriennummer in Einstellungen->Geräte angezeigt)")]),e._v(" "),r("li",[e._v("die 3-Byte Geräteadresse (wird in einer Konfigurationsdatei im Dateisystem gespeichert)")])]),e._v(" "),r("p",[e._v("Beide dürfen in einer HomeMatic-Installation nur "),r("strong",[e._v("1x vergeben")]),e._v(" werden."),r("br"),e._v("\nAusschlaggebend für die Funk-Kommunikation ist die Geräte-Adresse.")])]),e._v(" "),r("p",[e._v("Die Geräteadresse (im Sketch als "),r("code",[e._v("Device ID")]),e._v(" bezeichnet) lautet in diesem Fall "),r("code",[e._v("0x12,0x09,0x01")]),e._v("."),r("br"),e._v("\nDie Seriennummer (im Sketch als "),r("code",[e._v("Device Serial")]),e._v(" bezeichnet) lautet in diesem Fall "),r("code",[e._v("JPLRCP2001")]),e._v(".")]),e._v(" "),r("p",[e._v("Soll ein weiterer, auf diesen Sketch basierender HM-RC-P1 ins HomeMatic System integriert werden, verwendet man (- so mache ich es zumindest-) am besten eine fortlaufende Numerierung. 0x12, 0x09, 0x02 / JPLRCP2002.")]),e._v(" "),r("p",[e._v("Wichtig: Die Seriennummer muss immer 10-stellig sein! Sie darf Buchstaben und Zahlen enthalten.")]),e._v(" "),r("h2",{attrs:{id:"anschluss-des-ftdi-adapters"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#anschluss-des-ftdi-adapters"}},[e._v("#")]),e._v(" Anschluss des FTDI Adapters")]),e._v(" "),r("p",[e._v("Um die Schaltung sehr kompakt zu halten, verzichtet man auf das Anlöten eines Steckverbinders.\nEs reicht aus, wenn man die Pins des FTDI Adapters durch die Lötbohrungen steckt und während des Flash-Vorgangs verkantet.")]),e._v(" "),r("div",{staticClass:"custom-block warning"},[r("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),r("p",[e._v("Der FTDI muss auf 3,3V gejumpert sein da das CC1101 Funkmodul mit 5V beschädigt werden könnte.")])]),e._v(" "),r("p",[r("img",{attrs:{src:t(637),alt:"FTP Adapter verkantet am Arduino Pro Mini"}})]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("PIN Arduino")]),e._v(" "),r("th",[e._v("PIN FTDI")]),e._v(" "),r("th")])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("DTR")]),e._v(" "),r("td",[e._v("DTR")]),e._v(" "),r("td",[e._v("Data Terminal Ready")])]),e._v(" "),r("tr",[r("td",[e._v("RX")]),e._v(" "),r("td",[e._v("TX")]),e._v(" "),r("td",[e._v("Datentransfer")])]),e._v(" "),r("tr",[r("td",[e._v("TX")]),e._v(" "),r("td",[e._v("RX")]),e._v(" "),r("td",[e._v("Datentransfer")])]),e._v(" "),r("tr",[r("td",[e._v("VCC")]),e._v(" "),r("td",[e._v("VCC")]),e._v(" "),r("td",[e._v("Spannung")])]),e._v(" "),r("tr",[r("td"),e._v(" "),r("td",[e._v("CTS")]),e._v(" "),r("td",[e._v("Wird nicht verwendet")])]),e._v(" "),r("tr",[r("td",[e._v("GND")]),e._v(" "),r("td",[e._v("GND")]),e._v(" "),r("td",[e._v("Masse")])])])]),e._v(" "),r("h2",{attrs:{id:"platformio"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#platformio"}},[e._v("#")]),e._v(" PlatformIO")]),e._v(" "),r("p",[e._v("PlatformIO gibt es als vollständige "),r("a",{attrs:{href:"https://platformio.org/platformio-ide",target:"_blank",rel:"noopener noreferrer"}},[e._v("Entwicklungsumgebung"),r("OutboundLink")],1),e._v(" (IDE) und als "),r("a",{attrs:{href:"https://platformio.org/install/cli",target:"_blank",rel:"noopener noreferrer"}},[e._v("Command-Line-Interface"),r("OutboundLink")],1),e._v(" (CLI). Wer nicht tiefer in die Programmierung einsteigen möchte ist mit der CLI-Version ausreichend bedient.")]),e._v(" "),r("p",[e._v("Die nötigen Bibliotheken können über den "),r("a",{attrs:{href:"https://docs.platformio.org/en/latest/librarymanager/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Library Manager"),r("OutboundLink")],1),e._v("\nbequem installiert werden. Er enthält neben den gebräuchlichen EnableInterrupt und Low-Power auch AskSinPP.")]),e._v(" "),r("p",[e._v("Die Konfiguration des Boards kann über das Interface eingestellt werden und wird in der "),r("code",[e._v("platformio.ini")]),e._v(" im\nProjekt-Verzeichnis gespeichert. Diese Datei kann man sich also auch schnell selbst erstellen:")]),e._v(" "),r("div",{staticClass:"language-ini line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-ini"}},[r("code",[r("span",{pre:!0,attrs:{class:"token selector"}},[e._v("[platformio]")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token constant"}},[e._v("src_dir")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token attr-value"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),e._v(" .")]),e._v("\n\n"),r("span",{pre:!0,attrs:{class:"token selector"}},[e._v("[env:pro8MHzatmega328]")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token constant"}},[e._v("platform")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token attr-value"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),e._v(" atmelavr")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token constant"}},[e._v("framework")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token attr-value"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),e._v(" arduino")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token constant"}},[e._v("board")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token attr-value"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),e._v(" pro8MHzatmega328")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token constant"}},[e._v("monitor_speed")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token attr-value"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),e._v(" 57600")]),e._v("\n\n"),r("span",{pre:!0,attrs:{class:"token constant"}},[e._v("lib_deps")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token attr-value"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")])]),e._v("\n  AskSinPP\n  EnableInterrupt\n  Low-Power\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br")])]),r("p",[e._v("Einige Projekte bringen bereits eine "),r("code",[e._v("platformio.ini")]),e._v(" mit und man kann mit "),r("code",[e._v("platformio run -t upload")]),e._v(" den Code\nkompilieren und direkt flashen ohne weitere Einstellungen vornehmen zu müssen.")]),e._v(" "),r("p",[e._v("Manchmal kommt es vor, dass PlatformIO versucht ein falsches USB-Gerät anzusprechen. Hier kann mit "),r("code",[e._v("platformio device list")]),e._v("\nder Pfad des FTDI ermittelt werden. Dieser Pfad wird als Argument bei "),r("code",[e._v("run")]),e._v(" übergeben.\nBsp.: "),r("code",[e._v("platformio run -t upload --upload-port /dev/ttyUSB0")])]),e._v(" "),r("h2",{attrs:{id:"arduino-ide"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#arduino-ide"}},[e._v("#")]),e._v(" Arduino IDE")]),e._v(" "),r("p",[e._v("Die "),r("a",{attrs:{href:"https://www.arduino.cc/en/Main/Software",target:"_blank",rel:"noopener noreferrer"}},[e._v("Arduino IDE"),r("OutboundLink")],1),e._v(" ist die gebräuchlichste\nPC Software für den Umgang mit dem Arduino.")]),e._v(" "),r("h3",{attrs:{id:"bibliothek-einbinden"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bibliothek-einbinden"}},[e._v("#")]),e._v(" Bibliothek einbinden")]),e._v(" "),r("p",[e._v("Damit die im Sketch verwendeten Bibliotheken zur Verfügung stehen, müssen diese eingebunden werden:")]),e._v(" "),r("ul",[r("li",[e._v("AskSinPP")]),e._v(" "),r("li",[e._v("EnableInterrupt")]),e._v(" "),r("li",[e._v("Low-Power")])]),e._v(" "),r("p",[e._v("Die Release-Branches der AskSinPP (V#) sind dazu gedacht, eine stabile Basis für Geräte zu sein, ohne die Weiterentwicklung einzuschränken.")]),e._v(" "),r("p",[e._v("Bitte nutzt den V4 Branch für Eure Geräte.")]),e._v(" "),r("p",[e._v("Der Master-Zweig wird für die aktive Entwicklung verwendet und kann instabil sein.")]),e._v(" "),r("p",[e._v("Ausnahme: Einige Geräte wie HB-UNI-Sen-WEA oder HB-UNI-Sensor1 nutzen neuere Features und benötigen deswegen den Master-branch.\nDies sollte in der Readme zum jeweiligen Gerät dokumentiert sein.")]),e._v(" "),r("p",[e._v("Die AskSinPP Bibliothek kann als ZIP-Datei für den "),r("a",{attrs:{href:"https://codeload.github.com/pa-pa/AskSinPP/zip/V4",target:"_blank",rel:"noopener noreferrer"}},[e._v("V4 Release-Branch"),r("OutboundLink")],1),e._v(" bzw. für den "),r("a",{attrs:{href:"https://codeload.github.com/pa-pa/AskSinPP/zip/master",target:"_blank",rel:"noopener noreferrer"}},[e._v("Master-branch"),r("OutboundLink")],1),e._v(" heruntergeladen werden.")]),e._v(" "),r("p",[e._v("Anschließend geht man in der Arduino IDE auf "),r("code",[e._v("Sketch > Bibliothek einbinden > .ZIP-Bibliothek hinzufügen")]),e._v("\nund wählt die ZIP-Datei aus.")]),e._v(" "),r("p",[e._v("EnableInterrupt und Low-Power wird über "),r("code",[e._v("Sketch > Bibliothek einbinden > Bibliotheken verwalten")]),e._v("\ngesucht und installiert.")]),e._v(" "),r("h3",{attrs:{id:"board-einstellen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#board-einstellen"}},[e._v("#")]),e._v(" Board einstellen")]),e._v(" "),r("ul",[r("li",[e._v("Board: "),r("code",[e._v("Arduino Pro or Pro Mini")])]),e._v(" "),r("li",[e._v("Prozessor: "),r("code",[e._v("ATmega328P (3.3V, 8 MHz)")])]),e._v(" "),r("li",[e._v("Port: COM-Port des FTDI Adapters")])]),e._v(" "),r("h2",{attrs:{id:"flashen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flashen"}},[e._v("#")]),e._v(" Flashen")]),e._v(" "),r("p",[e._v("Sind die Werte angepasst, kann der Programmcode kompiliert und an den Mikrocontroller\nübertragen werden. In der Arduino IDE heißt dieser Vorgang "),r("code",[e._v("Sketch hochladen")]),e._v("\nund bei PlatformIO "),r("code",[e._v("upload")]),e._v(".")]),e._v(" "),r("p",[e._v("Unter Device-Model wird ein zweistelliger Hexwert verwendet. Dieser Wert kann mehrfach vorkommen.\nDurch diesen Wert wird das Format der Kommunikation vom und zum Gerät beschrieben. Weitere\nvon diesem Wert abhängigen Informationen sind im WebGUI sichtbar. So wird das Geräte-Icon\nund die Darstellung der vom Gerät übertragenen Werte über die Device-Model referenziert.")]),e._v(" "),r("p",[e._v("Für die HM-Geräte und 1:1 Nachbauten sind die Device-Model in der CCU vorhanden. Für eigene\nGeräte (Homebrew) werden sie z.B. über Addons hinzugefügt.")]),e._v(" "),r("p",[e._v("Im Beispiel ist das Device-Model "),r("code",[e._v("{0x00,0x1a}")]),e._v(". Über die Liste "),r("RouterLink",{attrs:{to:"/rftypes/"}},[e._v("RF-Types")]),e._v(" findet man, dass dieses\nDevice-Model "),r("code",[e._v("0x001A")]),e._v(" der FunkPankiHandsender HM-RC-P1 ist, also ein Original HM-Gerät\nund damit Icon und Beschreibung der Darstellung in der CCU schon vorhanden sind.")],1),e._v(" "),r("p",[e._v("Das Feld Firmware beinhaltet einen HEX-Wert, der in der Web-GUI als zwei Ziffeern angezeigt wird.\nAus "),r("code",[e._v("0x11")]),e._v(' wird dann "Firmware Version 1.1". Wenn auf die CCU eine höhere Firmware eingespielt wurde kann diese bei OTA-fähigen Geräten dann upgedatet werden.')]),e._v(" "),r("p",[e._v("In der über das Device-Model referenzierten Konfiguration kann auch eine von der Firmwareversion\nabhängige Funktionalität enthalten sein, um etwa Varianten ab einer bestimmten Version zu ermöglichen.")]),e._v(" "),r("p",[e._v("Der Device-Type beschreibt eine Klasse an Geräten. So können etwa Taster mit unterschiedlicher Anzahl\nan Tasten (und damit unterschiedlichem Device-Model) an anderen Stellen wieder gemeinschaftlich\nbehandelt werden.")]),e._v(" "),r("p",[e._v("Und letzlich gibt des noch die zweistellige HEX-Angabe Device-Info, wo weitere Details des Gerätes\nbeschrieben werden.")]),e._v(" "),r("h2",{attrs:{id:"serieller-monitor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#serieller-monitor"}},[e._v("#")]),e._v(" Serieller Monitor")]),e._v(" "),r("p",[e._v("Der Arduino verfügt über eine Debug-Ausgabe die vom PC über den "),r("code",[e._v("seriellen Monitor")]),e._v("\nabgerufen werden kann:")]),e._v(" "),r("ul",[r("li",[e._v("Arduino IDE: Menü > Werkzeuge > serieller Monitor")]),e._v(" "),r("li",[e._v("PlatformIO CLI: "),r("code",[e._v("platformio device monitor")])])]),e._v(" "),r("p",[e._v("Aus dem Sketch kann man die verwendete Baudrate ablesen:")]),e._v(" "),r("div",{staticClass:"language-cpp line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-cpp"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("setup")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("DINIT")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("57600")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("ASKSIN_PLUS_PLUS_IDENTIFIER"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  sdev"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("init")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("hal"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br")])]),r("p",[e._v("Hier also "),r("strong",[e._v("57600 Baud")]),e._v(". Diese muss beim Verbindungsaufbau übereinstimmen, damit man\nnicht nur wirre Zeichen erhält. Es ist zu empfehlen nach jedem Flashvorgang einen Blick auf\ndie Ausgaben zu werfen.\nFür den Fall, dass man mit "),r("strong",[e._v("115200")]),e._v(" Baud eine Verbindung/lebare Zeichen bekommt, verwendet man eine 16MHz Pro Mini.\nAchtung die haben meistens auch "),r("strong",[e._v("5V")]),e._v(" VCC und zerstören potentiell das CC1101 Funkmodul.")]),e._v(" "),r("div",{staticClass:"language-ini line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-ini"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Version")]),e._v("\nAskSin++ V4.1.0 (Aug 25 2019 00:08:04)\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Speicherbereich für Peerings und deren Parameter")]),e._v("\nAddress Space: 32 - 870\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Funkmodul Init und Version")]),e._v("\nCC init1\nCC Version: 14\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Device ist gebootet")]),e._v("\n - ready\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Device-ID und Serial (wird nicht immer ausgegeben)")]),e._v("\nID: 120901  Serial: JPLRCP2001\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Funkverkehr:  <- ausgehend;  -> eingehend")]),e._v("\n<- 0F 01 86 10 0108F2 000000 06 01 00 00 00 00  - 7528\n<- 0F 02 86 10 0108F2 000000 06 02 00 00 00 00  - 7626\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br"),r("span",{staticClass:"line-number"},[e._v("14")]),r("br")])]),r("p",[e._v("Weiteres zum "),r("RouterLink",{attrs:{to:"/Grundlagen/FAQ/Debugging.html"}},[e._v("Debugging")]),e._v(" in den FAQ.")],1),e._v(" "),r("h2",{attrs:{id:"ota-firmware-updates"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ota-firmware-updates"}},[e._v("#")]),e._v(" OTA (Firmware-Updates)")]),e._v(" "),r("p",[e._v('Geräte mit AskSin++ können über die CCU sowie über FHEM mit neuer Software bespielt werden.\nDas funktioniert wie bei gewöhnlichen HomeMatic Geräten über die "Geräte-Firmware"-Übersicht.')]),e._v(" "),r("div",{staticClass:"custom-block warning"},[r("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),r("p",[e._v("OTA-Updates über die CCU dürfen nur bei eigenen Gerätedefinitionen gemacht werden, nicht bei Geräten,\ndie offiziell existieren.")]),e._v(" "),r("ul",[r("li",[e._v("ein unabsichtliches Flashen von echten HomeMatic-Geräten mit der AskSin++-Firmware wird diese "),r("strong",[e._v("unbrauchbar")]),e._v(" machen")]),e._v(" "),r("li",[e._v("viele offizielle Geräte haben nicht die nötigen Parameter und Einstellungen in der Gerätedefinition für OTA-Updates oder nutzen andere Mikrocontroller")])])]),e._v(" "),r("h3",{attrs:{id:"bootloader-erstellen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bootloader-erstellen"}},[e._v("#")]),e._v(" Bootloader erstellen")]),e._v(" "),r("p",[e._v("Um die Geräte per OTA-Update mit Software versorgen zu können, ist ein spezieller Bootloader nötig, der auf die Geräte aufgespielt werden muss.\nDas kann bei den üblichen Arduino Pro Minis leider nicht über die serielle Schnittstelle (FTDI) erfolgen, sondern muss mit einem AVR ISP-Programmer gemacht werden.\nDurch das Installieren des OTA-Bootloaders wird auch der Arduino-Bootloader ersetzt, was zur Folge hat, dass eine Programmierung der Arduinos nur noch per ISP (und natürlich per OTA) möglich ist.")]),e._v(" "),r("p",[e._v('Damit die Firmware nicht für jedes Gerät individuell gebaut werden muss, verschieben sich die Geräteinformationen (Seriennummer, Geräteadresse) in den Bootloader.\nDer Bootloader wird also "personalisiert" für jedes Gerät erstellt und geflasht. Die Firmware kann dann auf alle (baugleichen) Sensoren über die CCU übertragen werden.')]),e._v(" "),r("p",[e._v('Im Sketch muss das "'),r("code",[e._v("USE_OTA_BOOTLOADER")]),e._v('" einkommentiert werden. Dieses sorgt dafür, dass die Firmware die Geräteinformationen aus dem Bootloader liest:')]),e._v(" "),r("div",{staticClass:"language-cpp line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-cpp"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// define this to read the device id, serial and device type from bootloader section")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token macro property"}},[r("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),r("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("define")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token macro-name"}},[e._v("USE_OTA_BOOTLOADER")])]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br")])]),r("p",[e._v("Mit dieser Änderung wird jetzt eine neue Firmware gebaut und wir benötigen das resultierende .hex-File."),r("br"),e._v("\nIn der Arduino IDE kann die Firmware über Sketch->Kompilierte Binärdatei exportieren gespeichert werden."),r("br"),e._v("\nBei PlatformIO findet sich diese in "),r("code",[e._v("Projektordner/.pio/build/pro8MHzatmega328/firmware.hex")]),e._v(".")]),e._v(" "),r("p",[e._v("Nun benötigen wir den Bootloader selbst:"),r("br"),e._v("\nDieser ist im AskSin++-Git enthalten und kann von uns entweder per "),r("code",[e._v("git clone https://github.com/pa-pa/AskSinPP")]),e._v(" oder als "),r("a",{attrs:{href:"https://github.com/pa-pa/AskSinPP/archive/master.zip",target:"_blank",rel:"noopener noreferrer"}},[e._v(".zip Download"),r("OutboundLink")],1),e._v(" runtergeladen werden. Im Ordner "),r("code",[e._v("bootloader/avr/")]),e._v(" befindet sich die "),r("code",[e._v("makeota.html")]),e._v("."),r("br"),e._v("\nDiese Datei kann mit einem Webbrowser geöffnet werden und erstellt uns einen Bootloader mit den gewünschten Parametern.\n"),r("img",{attrs:{src:t(638),alt:"makeota.html"}})]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("MCU Type")]),e._v(" bleibt auf ATmega328 (für die normalen Arduino ProMini)")]),e._v(" "),r("li",[r("strong",[e._v("Device Model")]),e._v(" ist der Geräte-Typ, also z.B. FA01")]),e._v(" "),r("li",[r("strong",[e._v("HM ID")]),e._v(" ist die Geräteadresse (3 Bytes), z.B. 210001")]),e._v(" "),r("li",[r("strong",[e._v("HM Serial")]),e._v(" ist die Seriennummer, z.B. ASKS210001")]),e._v(" "),r("li",[r("strong",[e._v("Config string")]),e._v(" kann zusätzliche Konfigurationseinstellungen für die Firmware speichern, kann auf 0 gelassen werden.")])]),e._v(" "),r("p",[e._v("Unter "),r("strong",[e._v("Firmware")]),e._v(' wird dann unsere .hex-Datei mit der gewünschten Firmware hochgeladen.\nNach einem Klick auf "Create Bootloader" bekommen wir dann eine .hex-Datei mit der HM Serial als Namen heruntergeladen.'),r("br"),e._v("\nDiese Datei enthält den Bootloader, die Konfiguration sowie unsere Firmware und kann so 1:1 auf den AVR geflashed werden.")]),e._v(" "),r("h3",{attrs:{id:"bootloader-flashen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bootloader-flashen"}},[e._v("#")]),e._v(" Bootloader flashen")]),e._v(" "),r("p",[e._v("Die Firmware kann nun auf den AVR geflashed werden. Dazu können verschiedene Tools genutzt werden.")]),e._v(" "),r("p",[e._v("Über die Konsole erfolgt das Flashen folgendermaßen:")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[e._v("avrdude -p m328p -c stk500v2 -P /dev/ttyUSB0 -U lfuse:w:0xE2:m -U hfuse:w:0xD0:m\navrdude -p m328p -c stk500v2 -P /dev/ttyUSB0 -V -U flash:w:ASKS21001.hex\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br")])]),r("p",[e._v("Die Parameter -c (Programmieradaptertyp) und -P (Port) müssen entsprechend für den genutzten AVR ISP-Programmer abgeändert werden.\nDie Fuses nutzen den internen 8 MHz RC-Oszillator, deaktivieren die Brown-Out Erkennung, deaktivieren das Löschen des EEPROM beim Flashen und konfigurieren den Resetvektor des Bootloaders.")]),e._v(" "),r("p",[e._v("Nach dem Flashen funktioniert das Gerät wie gewohnt und kann an die CCU angelernt werden.")]),e._v(" "),r("h3",{attrs:{id:"firmware-fur-ccu-verpacken"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#firmware-fur-ccu-verpacken"}},[e._v("#")]),e._v(" Firmware für CCU verpacken")]),e._v(" "),r("p",[e._v("Um nun eine neue Firmware zu übertragen, wird wieder eine .hex-Datei mit der neuen Firmware erstellt."),r("br"),e._v('\nHierbei ist darauf zu achten, dass der "Firmware Version"-Parameter im DeviceInfo struct auf die neue Firmwareversion aktualisiert wird:')]),e._v(" "),r("div",{staticClass:"language-cpp line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-cpp"}},[r("code",[e._v("    "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x12")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("                   "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Firmware Version")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("p",[e._v("0x12 ist die Version 1.2, 0x34 wäre Version 3.4.")]),e._v(" "),r("p",[e._v("Das Tool prepota.sh im Bootloader-Ordner kann nun die .hex-Datei in eine .eq3-Datei umwandeln."),r("br"),e._v("\nHierzu wird auf der Konsole das Script prepota.sh genutzt:")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[e._v("./prepota.sh neueFirmwareVersion1.2.hex\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("p",[e._v("Unter Windows kann dies entweder im Windows 10 Subsystem for Linux oder über Cygwin (bash, sed) erfolgen. Unter Linux und Mac sollten alle erforderlichen Abhängigkeiten bereits vorhanden sein.\nWenn der Download des AskSin++-Quelltextes als .zip-Datei erfolgt ist, kann es evtl. nötig sein, die Datei als Ausführbar zu markieren.\nDas kann mit "),r("code",[e._v("chmod +x prepota.sh")]),e._v(" erledigt werden.\nDas Tool ist relativ langsam, Laufzeiten von 30 Sekunden können durchaus auftreten.")]),e._v(" "),r("p",[e._v("Ein Firmware-Update für die CCU besteht aus 3 Dateien:")]),e._v(" "),r("ul",[r("li",[e._v("firmware_aktuellesDatum.eq3")]),e._v(" "),r("li",[e._v("changelog.txt")]),e._v(" "),r("li",[e._v("info")])]),e._v(" "),r("p",[e._v("Diese 3 Dateien werden als .tar.gz-Archiv verpackt.")]),e._v(" "),r("p",[e._v("Unter Windows lässt sich das .tar.gz-Archiv mit dem Tool 7-Zip erstellen."),r("br"),e._v("\nDie Datei info (ohne Dateiendung!) enthält folgende Informationen:")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("TypeCode=64001\nName=HB-Sen-Env-I\nCCUFirmwareVersionMin=2.27.0\nCCU3FirmwareVersionMin=3.27.0\nFirmwareVersion=1.2\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br")])]),r("ul",[r("li",[e._v("TypeCode ist die Device Model ID (in diesem Beispiel 0xFA01) allerdings in "),r("a",{attrs:{href:"https://www.google.com/search?q=0xFA01+in+decimal",target:"_blank",rel:"noopener noreferrer"}},[e._v("dezimaler Schreibweise"),r("OutboundLink")],1),e._v(".")]),e._v(" "),r("li",[e._v("Name ist der genaue Name (auf Groß- und Kleinschreibung achten!) aus der .xml-Gerätedefinition.")]),e._v(" "),r("li",[e._v("CCU und CCU3FirmwareVersionMin ist die minimale Version der CCU-Firmware, die benötigt wird.")]),e._v(" "),r("li",[e._v("FirmwareVersion ist die Version der Firmware, die in diesem Ordner enthalten ist.")])]),e._v(" "),r("p",[e._v("Die Datei sollte mit Unix-Zeichenenden (LF, \\n) gespeichert werden."),r("br"),e._v("\nDie changelog.txt enthält natürlichen Text mit Informationen über diese Firmware-Version.")]),e._v(" "),r("p",[e._v("Die fertige .tar.gz-Datei mit der Firmware muss folgendermaßen aussehen:"),r("br"),e._v(" "),r("img",{attrs:{src:t(639),alt:".tar.gz Datei mit 3 Dateien"}})]),e._v(" "),r("h3",{attrs:{id:"ota-update-starten"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ota-update-starten"}},[e._v("#")]),e._v(" OTA-Update starten")]),e._v(" "),r("p",[e._v('Ein Firmware-Update kann wie üblich über die CCU gestartet werden.\nNach dem Klick auf "Update" beim entsprechenden Gerät wird zunächst eine Fehlermeldung auftreten.\nDas Update wurde dennoch vorgemerkt. Durch einen Druck auf den Gerätetaster am entsprechenden Gerät wird das Update dann gestartet.')])])}),[],!1,null,null,null);n.default=a.exports},637:function(e,n,t){e.exports=t.p+"assets/img/ftdi-verkantet.9eedbe7c.jpg"},638:function(e,n,t){e.exports=t.p+"assets/img/makeotahtml.dc4d06f3.png"},639:function(e,n,t){e.exports=t.p+"assets/img/firmwareupdate.f88237d6.png"}}]);